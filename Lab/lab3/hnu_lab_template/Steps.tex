\section{Lab Steps 步骤}
\subsection{分析问题}
对于NFA转DFA的问题，常用子集法求解，可以通过求闭包的方式求得DFA的状态，然后编号即可求解问题。
但是在本题中，起始状态集合和接受状态集合都是用特征串对应的整数所表示的，举个例子:状态集合的子集{q0q1q2}，其特征串就是0111，而子集{q0}，其特征串就是0001。将对应的特征串转换为十进制的数字
\\在本题中，我们直接使用子集法可能并不是最佳的解题方法，因为特征串用递归的方式处理往往会更加方便！

\subsection{算法思想}

\begin{enumerate}
    \item 状态集合的子集合，采用二进制（特征）串的方式，一个子集中包含该状态，对应的特征串就为1，否则为0，比如上面状态集合的子集{q0q1q2}，其特征串就是0111，而子集{q0}，其特征串就是0001。
    \item 采用DFS的方式搜索整个状态图。
    \item 搜索过程中，对于每一个特征串p，用p $\oplus$ $-$p取出p的最后一个状态（最低非零位），分别根据状态转换表格搜索0，1到达的集合，维护到达状态序列Qlist和下标。
    \item 标记已访问过的状态，直到整个状态图搜索结束，根据记录的序列和下标调整标号，打印结果。
\end{enumerate}
\subsubsection{对特征串的处理:}
\begin{itemize}
    \item x$\wedge $ $-$x: lowbit运算，返回最低位1表示的值
    \item lowbit x $\oplus$ x运算: 剔除最低位的1
\end{itemize}

\newpage
\subsubsection{算法伪代码表述：}
经过上述分析，算法伪代码可以表述为：
\lstinputlisting[language=c]
{./Code/mind.cpp}

